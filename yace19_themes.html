function buildDNA(){
  dnaGroup.clear();
  const N = SYSTEMS.length;
  const helixRadius = 55;
  const helixHeight = 600;
  const helixTurns = 3;

  const strandPts1 = [];
  const strandPts2 = [];
  for(let t=0;t<=200;t++){
    const frac = t/200;
    const angle = frac*Math.PI*2*helixTurns;
    const z = (frac-0.5)*helixHeight;
    strandPts1.push(new THREE.Vector3(helixRadius*Math.cos(angle), helixRadius*Math.sin(angle), z));
    strandPts2.push(new THREE.Vector3(helixRadius*Math.cos(angle+Math.PI), helixRadius*Math.sin(angle+Math.PI), z));
  }
  const curve1 = new THREE.CatmullRomCurve3(strandPts1);
  const curve2 = new THREE.CatmullRomCurve3(strandPts2);
  const tubeMat1 = new THREE.MeshBasicMaterial({color:0x06b6d4,transparent:true,opacity:0.35});
  const tubeMat2 = new THREE.MeshBasicMaterial({color:0xa855f7,transparent:true,opacity:0.35});
  dnaGroup.add(new THREE.Mesh(new THREE.TubeGeometry(curve1,200,0.35,8,false), tubeMat1));
  dnaGroup.add(new THREE.Mesh(new THREE.TubeGeometry(curve2,200,0.35,8,false), tubeMat2));

  SYSTEMS.forEach((sys,i)=>{
    const frac = (i/(N-1));
    const angle = frac*Math.PI*2*helixTurns;
    const zA = (frac-0.5)*helixHeight;
    const xA = helixRadius*Math.cos(angle);
    const yA = helixRadius*Math.sin(angle);
    const xB = helixRadius*Math.cos(angle+Math.PI);
    const yB = helixRadius*Math.sin(angle+Math.PI);
    const col = new THREE.Color(sys.color);

    const sMesh = new THREE.Mesh(new THREE.SphereGeometry(sys.size*0.65,20,20), new THREE.MeshBasicMaterial({color:col}));
    sMesh.position.set(xA,yA,zA);
    sMesh.userData = {system:sys, baseScale:1};
    meshToSystem.set(sMesh.uuid, sys);
    dnaGroup.add(sMesh);

    const gMat = new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.07,side:THREE.BackSide});
    const glow = new THREE.Mesh(new THREE.SphereGeometry(sys.size*1.5,12,12), gMat);
    glow.position.set(xA,yA,zA);
    dnaGroup.add(glow);

    const s2Mesh = new THREE.Mesh(new THREE.SphereGeometry(sys.size*0.45,16,16), new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.5}));
    s2Mesh.position.set(xB,yB,zA);
    dnaGroup.add(s2Mesh);

    const rGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(xA,yA,zA), new THREE.Vector3(xB,yB,zA)]);
    dnaGroup.add(new THREE.Line(rGeo, new THREE.LineBasicMaterial({color:col,transparent:true,opacity:0.22})));

    const sprite = makeLabel(sys.label, sys.color);
    sprite.position.set(xA, yA+sys.size*1.3, zA);
    sprite.userData = {isLabel:true};
    dnaGroup.add(sprite);

    sys._pos_dna = new THREE.Vector3(xA,yA,zA);
  });
}

/* ═══════════════════════════════ SPRITE LABELS ═══════════════ */
    function makeLabel(text, color) {
      const canvas2 = document.createElement('canvas');
      canvas2.width = 256; canvas2.height = 48;
      const ctx = canvas2.getContext('2d');
      ctx.clearRect(0, 0, 256, 48);
      ctx.font = '700 13px Inter,system-ui,sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.85;
      ctx.fillText(text, 128, 30);
      const tex = new THREE.CanvasTexture(canvas2);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(16, 3, 1);
      return sp;
    }

    /* ═══════════════════════════════ INTERACTION ════════════════ */
    function getIntersects() {
      raycaster.setFromCamera(mouse, camera);
      const group = currentTheme === 'galaxy' ? galaxyGroup : dnaGroup;
      const meshes = [];
      group.traverse(obj => {
        if (obj.isMesh && obj.userData.system) meshes.push(obj);
      });
      return raycaster.intersectObjects(meshes, false);
    }

    window.addEventListener('mousemove', e => {
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    });

    window.addEventListener('click', e => {
      const hits = getIntersects();
      if (hits.length > 0) {
        const sys = hits[0].object.userData.system;
        showCard(sys);
      }
    });

    /* ═══════════════════════════════ CARD ═══════════════════════ */
    function showCard(sys) {
      selectedSystem = sys;
      document.getElementById('c-path').textContent = sys.path;
      document.getElementById('c-label').textContent = sys.label;
      document.getElementById('c-desc').textContent = sys.desc;
      const tagsEl = document.getElementById('c-tags');
      tagsEl.innerHTML = sys.tags.map(t => {
        const cls = t.includes('GATED') || t.includes('AUTH') ? 'gated' : t === 'SOVEREIGN' || t === 'COGNEE' ? 'sovereign' : t === 'PUBLIC' ? 'public' : '';
        return `<span class="c-tag ${cls}">${t}</span>`;
      }).join('');
      const visitEl = document.getElementById('c-visit');
      visitEl.textContent = `⟶ OPEN ${sys.label.toUpperCase()}`;
      visitEl.onclick = () => { window.open('https://yace19ai.com' + sys.url, '_blank'); };
      document.getElementById('card').classList.add('visible');
      // Fly camera to planet
      flyTo(currentTheme === 'galaxy' ? sys._pos_galaxy : sys._pos_dna);
    }

    function closeCard() {
      document.getElementById('card').classList.remove('visible');
      selectedSystem = null;
    }

    function flyTo(pos) {
      if (!pos) return;
      const target = pos.clone();
      const dist = 45;
      const dir = target.clone().normalize();
      const camTarget = target.clone().add(dir.multiplyScalar(-dist)).add(new THREE.Vector3(0, 15, 0));
      // Simple lerp animation
      const start = camera.position.clone();
      const startLook = new THREE.Vector3(0, 0, 0);
      const duration = 1200;
      const startTime = performance.now();
      function animate() {
        const t = Math.min((performance.now() - startTime) / duration, 1);
        const ease = 1 - Math.pow(1 - t, 3);
        camera.position.lerpVectors(start, camTarget, ease);
        camera.lookAt(target.lerp(startLook, 1 - ease));
        if (t < 1) requestAnimationFrame(animate);
      }
      animate();
    }

    /* ═══════════════════════════════ THEME SWITCH ════════════════ */
    function setTheme(theme) {
      currentTheme = theme;
      galaxyGroup.visible = theme === 'galaxy';
      dnaGroup.visible = theme === 'dna';
      document.getElementById('btn-galaxy').className = 'theme-btn ' + (theme === 'galaxy' ? 'active galaxy' : 'galaxy');
      document.getElementById('btn-dna').className = 'theme-btn ' + (theme === 'dna' ? 'active dna' : 'dna');
      document.getElementById('hud-theme').textContent = theme.toUpperCase();
      document.getElementById('theme-label').textContent = theme === 'galaxy'
        ? 'MILKY WAY — GALAXY VIEW — CLICK A SYSTEM TO EXPLORE'
        : 'DNA HELIX — EACH NUCLEOTIDE IS A LIVING PAGE — CLICK TO ENTER';
      closeCard();

      // Reset camera
      if (theme === 'galaxy') {
        camera.position.set(0, 60, 280);
        camera.lookAt(0, 0, 0);
      } else {
        camera.position.set(80, 0, 80);
        camera.lookAt(0, 0, 0);
      }
    }

    /* ═══════════════════════════════ AUTO-ROTATE ════════════════ */
    function toggleRotate() {
      autoRotate = !autoRotate;
      const btn = document.getElementById('rotate-btn');
      btn.className = 'rotate-btn' + (autoRotate ? ' on' : '');
      btn.textContent = autoRotate ? '◉ ORBITING' : '◎ AUTO-ORBIT';
    }

    /* ═══════════════════════════════ ORBIT CONTROL (simple) ═════ */
    let isDragging = false, prevX = 0, prevY = 0, sphericalTheta = 0, sphericalPhi = Math.PI / 3, sphericalR = 280;
    canvas.addEventListener('mousedown', e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = (e.clientX - prevX) * 0.005;
      const dy = (e.clientY - prevY) * 0.005;
      sphericalTheta -= dx;
      sphericalPhi = Math.max(0.1, Math.min(Math.PI - 0.1, sphericalPhi + dy));
      prevX = e.clientX; prevY = e.clientY;
    });
    canvas.addEventListener('wheel', e => {
      sphericalR = Math.max(40, Math.min(600, sphericalR + e.deltaY * 0.4));
      e.preventDefault();
    }, { passive: false });

    /* ═══════════════════════════════ RESIZE ═════════════════════ */
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ═══════════════════════════════ RENDER LOOP ════════════════ */
    const clock = new THREE.Clock();

    function render() {
      requestAnimationFrame(render);
      const t = clock.getElapsedTime();

      // FPS counter
      fpsFrames++;
      const now = performance.now();
      if (now - fpsLast > 800) {
        fps = Math.round(fpsFrames * 1000 / (now - fpsLast));
        document.getElementById('hud-fps').textContent = fps;
        fpsFrames = 0; fpsLast = now;
      }

      // Auto-rotate
      if (autoRotate) {
        rotateAngle += 0.003;
        const group = currentTheme === 'galaxy' ? galaxyGroup : dnaGroup;
        group.rotation.y = rotateAngle;
        stars.rotation.y = rotateAngle * 0.05;
      } else if (!isDragging) {
        // Manual orbit camera
        const cx = sphericalR * Math.sin(sphericalPhi) * Math.sin(sphericalTheta);
        const cy = sphericalR * Math.cos(sphericalPhi);
        const cz = sphericalR * Math.sin(sphericalPhi) * Math.cos(sphericalTheta);
        camera.position.set(cx, cy, cz);
        camera.lookAt(0, 0, 0);
      }

      // DNA helix own rotation (gentle)
      if (currentTheme === 'dna' && !autoRotate) {
        dnaGroup.rotation.y = t * 0.06;
      }

      // Star slow drift
      stars.rotation.y = t * 0.005;
      stars.rotation.x = t * 0.002;

      // Hover detection
      const hits = getIntersects();
      const group = currentTheme === 'galaxy' ? galaxyGroup : dnaGroup;
      group.traverse(obj => {
        if (obj.isMesh && obj.userData.system) {
          const isHover = hits.length > 0 && hits[0].object === obj;
          const base = obj.userData.baseScale || 1;
          const pulse = 1 + 0.06 * Math.sin(t * 2 + obj.id);
          obj.scale.setScalar(isHover ? base * 1.35 : base * pulse);
          document.body.style.cursor = isHover ? 'pointer' : 'default';
        }
      });

      renderer.render(scene, camera);
    }

    /* ═══════════════════════════════ INIT ═══════════════════════ */
    buildGalaxy();
    buildDNA();
    render();

    /* keyboard shortcut */
    window.addEventListener('keydown', e => {
      if (e.key === 'g' || e.key === 'G') setTheme('galaxy');
      if (e.key === 'd' || e.key === 'D') setTheme('dna');
      if (e.key === 'r' || e.key === 'R') toggleRotate();
      if (e.key === 'Escape') closeCard();
    });
  </script>
</body>

</html>